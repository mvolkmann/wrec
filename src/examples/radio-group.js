import Wrec, {css, html} from '../wrec';

/**
 * A group of radio buttons.
 * @tag radio-group
 * @csspart none
 * @cssproperty [--border-color=black] - the fieldset border color
 * @cssproperty [--direction=row] - the direction of the radio buttons
 * @cssproperty [--gap=1rem] - the gap between the radio buttons
 * @cssproperty --legend-color - the color of the legend text
 * @slot before - optional content to insert before the radio buttons
 * @slot after - optional content to insert after the radio buttons
 */
class RadioGroup extends Wrec {
  static formAssociated = true;

  static properties = {
    labels: {type: String},
    legend: {type: String},
    name: {type: String, required: true},
    values: {type: String},
    value: {type: String}
  };

  static css = css`
    :host > div {
      display: flex;
      gap: 0.5rem;
    }

    fieldset {
      border-color: var(--border-color, 'black');
      display: inline-flex;
      flex-direction: column;
      align-items: start;
      gap: 0.5rem;

      > legend {
        color: var(--legend-color, 'black');
      }

      > div {
        display: flex;
        flex-direction: var(--direction, row);
        gap: var(--gap, 1rem);
      }
    }

    input {
      margin: 0;
    }
  `;

  // wrec requires a static html property.
  // Dynamic content inside it must be generated by a JavaScript expression
  // that can use "this." to refer to the current instance.
  static html = html`
    <fieldset>
      <legend style="this.displayIfSet(this.legend)">this.legend</legend>
      <slot name="before"></slot>
      <div>this.makeButtons(this.labels, this.values)</div>
      <slot name="after"></slot>
    </fieldset>
  `;

  connectedCallback() {
    super.connectedCallback();
    this.#fixValue();
  }

  // This handles the case when the specified value
  // is not in the list of values.
  #fixValue() {
    requestAnimationFrame(() => {
      const values = this.values.split(',');
      if (!this.value || !values.includes(this.value)) this.value = values[0];
    });
  }

  // This method cannot be private because it is called when
  // a change event is dispatched from a radio button.
  handleChange(event) {
    this.value = event.target.value;
  }

  makeButtons(labels, values) {
    const labelArray = labels.split(',');
    const valueArray = values.split(',').map(value => value.trim());
    // prettier-ignore
    return valueArray.map((value, index) => html`
      <div>
        <input
          type="radio"
          id=${value}
          name=${this.name}
          onchange="handleChange"
          value=${value}
          checked="this.value === '${value}'"
        />
        <label for=${value}>${labelArray[index]}</label>
      </div>
    `).join('');
  }

  propertyChangedCallback(propName) {
    if (propName === 'values') this.#fixValue();
  }
}

RadioGroup.register();
